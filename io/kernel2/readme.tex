\documentclass[letterpaper]{article}
% generated by Docutils <http://docutils.sourceforge.net/>
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{0}
\usepackage{longtable,ltcaption,array}
\setlength{\extrarowheight}{2pt}
\newlength{\DUtablewidth} % internal use in tables
\usepackage{tabularx}

%%% Custom LaTeX preamble
% PDF Standard Fonts
\usepackage{mathptmx} % Times
\usepackage[scaled=.90]{helvet}
\usepackage{courier}

%%% User specified packages and stylesheets
\usepackage{fullpage}
\usepackage{microtype}
\usepackage[htt]{hyphenat}

%%% Fallback definitions for Docutils-specific commands

% providelength (provide a length variable and set default, if it is new)
\providecommand*{\DUprovidelength}[2]{
  \ifthenelse{\isundefined{#1}}{\newlength{#1}\setlength{#1}{#2}}{}
}

% docinfo (width of docinfo table)
\DUprovidelength{\DUdocinfowidth}{0.9\textwidth}

% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
  \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
  \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}
\hypersetup{
  pdftitle={CS 452 K2},
}

%%% Title Data
\title{\phantomsection%
  CS 452 K2%
  \label{cs-452-k2}}
\author{}
\date{}

%%% Body
\begin{document}
\maketitle

% Docinfo
\begin{center}
\begin{tabularx}{\DUdocinfowidth}{lX}
\textbf{Names}: &
Robert Elder, Christopher Foo
\\
\textbf{ID \#}: &
20335246, 20309244
\\
\textbf{Userids}: &
relder, chfoo
\\
\textbf{Date due}: &
May 31, 2013
\\
\textbf{Extension date}: &
Jun 3, 2013
\\
\end{tabularx}
\end{center}


\section{Running%
  \label{running}%
}

The executable is located at \texttt{/u/cs452/tftp/ARM/relder-chfoo/k2a-submit/kern.elf}.

It is executed using the regular commands:
%
\begin{quote}{\ttfamily \raggedright \noindent
load~-b~0x00218000~-h~10.15.167.4~ARM/relder-chfoo/k2a-submit/kern.elf\\
go
}
\end{quote}


\section{Description%
  \label{description}%
}


\subsection{Kernel%
  \label{kernel}%
}


\subsubsection{Scheduling%
  \label{scheduling}%
}
%
\begin{itemize}

\item The blocked states are now used. They corresponds to those explained in the lecture:
%
\begin{itemize}

\item \texttt{RECEIVE\_BLOCKED}

\item \texttt{SEND\_BLOCKED}

\item \texttt{REPLY\_BLOCKED}

\end{itemize}

\item Tasks that are blocked are simply rescheduled by re-queueing it. Efficiency could be improved by having a separate blocked queue.

\end{itemize}


\subsubsection{System Calls%
  \label{system-calls}%
}
%
\begin{itemize}

\item Added support for 5th argument.

\end{itemize}

The system calls are not entirely complete according specifications and are noted below.
%
\begin{description}
\item[{\texttt{Send}}] \leavevmode 
The function behaves as expected except the error \texttt{-3} code is not implemented.

\item[{\texttt{Receive}}] \leavevmode 
The function behaves as expected. The size of the message sent would be typically 100 bytes since it is the convention used in the kernel.

\item[{\texttt{Reply}}] \leavevmode 
The function behaves as expected, however, errors \texttt{-3} \texttt{-4} include an assert that will aid in debugging.

\item[{\texttt{RegisterAs}}] \leavevmode 
The function behaves as expected. It uses the \texttt{NameServerMessage} structure and sends the message. \texttt{0} is always returned because the Task ID is hard-coded and the call should never send to the wrong task.

\item[{\texttt{WhoIs}}] \leavevmode 
The function behaves as expected. As noted in \texttt{RegisterAs}, we either return a Task ID or 0.

\end{description}


\subsection{Name Server%
  \label{name-server}%
}

File: \texttt{nameserver.c}

The name server uses a 2D \texttt{char} array. The maximum name is limited arbitrary to 100 letters including the null terminator. The array index corresponds to the Task ID for simplicity and constant time operations.

It does the following:
\newcounter{listcnt0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item \texttt{Receive} a message casted to \texttt{NameServerMessage}

\item Determine the request type.

\item Look up or set the value in the array.

\item If it receives a \texttt{NAME\_SERVER\_SHUTDOWN} message type, it will \texttt{Exit()}
\end{list}
%
\begin{itemize}

\item Requests to set the name multiple times overwrites the previous value.

\item 0 is returned when an invalid Task ID is provided.

\item The Task ID is hard-coded to \texttt{2}.

\end{itemize}


\subsection{Rock Paper Scissors%
  \label{rock-paper-scissors}%
}

File: \texttt{rps.h}

There are two server-client structures: \texttt{RPSServer} and \texttt{RPSClient}. \texttt{RPSMessage} is the message structure.

The kernel starts the \texttt{RPSServer} and 3 \texttt{RPSClient}. All of them are executed at \texttt{NORMAL} priority as to allow us to catch synchronization bugs.


\subsubsection{RPSServer%
  \label{rpsserver}%
}
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Registers with the name server

\item \texttt{Receive} and processes message with sign up, quit, and play types.

\item Outputs if there is only 1 or less items in the sign up queue.
\end{list}


\paragraph{Sign Up%
  \label{sign-up}%
}
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Add the task ID to the sign up queue.

\item Mark it as signed up on the sign up array.

\item \texttt{Reply} with a \texttt{SIGN\_UP\_OK} type message.
\end{list}


\paragraph{Quit:%
  \label{quit}%
}
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Mark it as quit (0) on the sign up array.

\item \texttt{Reply} with a \texttt{GOODBYE} type message.

\item The server is marked for shutdown.
\end{list}


\paragraph{Player Selection%
  \label{player-selection}%
}

Players are selected by going through the sign up queue. Players are not requeued if they have quit.


\paragraph{Play%
  \label{play}%
}
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Get the player's choice by matching the Task IDs

\item Once we have two choices, we can \texttt{Reply} with the outcome.

\item \texttt{Reply} a \texttt{NEGATIVE\_ACK} message type if the client cannot play yet.

\item \texttt{Reply} a \texttt{SHUTDOWN} message if any one signed up has quit.
%
\begin{itemize}

\item This design decision was made so that the shutdown case is well defined.

\end{itemize}
\end{list}


\subsubsection{RPSClient%
  \label{rpsclient}%
}

Each client wants to play 5 times.
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Look up the task ID of the \texttt{RPSServer}.

\item Sign up

\item Decide their choice and \texttt{Send} it.

\item If a \texttt{NEGATIVE\_WAIT} is received, try again. This is a simple polling method that is robust.
%
\begin{itemize}

\item This could be improved/avoided by having the \texttt{RPSServer} notify or \texttt{Send} to the client to let it know it is ready.

\end{itemize}

\item Read the message and print out results.

\item Waits for keyboard input
\end{list}


\subsection{Algorithms and Data structures%
  \label{algorithms-and-data-structures}%
}


\subsubsection{Queue%
  \label{queue}%
}

File: \texttt{queue.c}

A change was made so that it returns the current item count.


\subsubsection{Task Descriptor (TD)%
  \label{task-descriptor-td}%
}

File: \texttt{task\_descriptor.c}

The TD was modified so it contains message pointer such as the address of TID for \texttt{Receive}


\subsubsection{Kernel State%
  \label{kernel-state}%
}

File: \texttt{kernel\_state.h}

An array of \texttt{KernelMessage} and its related variables was added to the \texttt{KernelState}


\subsubsection{Memory Operations%
  \label{memory-operations}%
}

File: \texttt{memory.c}

Functions were added so that strings (potentially binary data) could be copied. They are simple and copy one \texttt{char} at a time.

Possible improvements: Instructions could be written in assembly that make use of the block copying mode.


\subsubsection{Kernel Message%
  \label{kernel-message}%
}

File: \texttt{message.h}

\texttt{KernelMessage} is a \texttt{struct} that contains the message string. It contains origin and destination IDs and pointers.


\subsubsection{Messages%
  \label{messages}%
}

Messages are \texttt{structs} that are casted into \texttt{char*}. This casting allows us to manipulate messages more easily with type safety rather than dealing with raw \texttt{char}. The message size is fixed arbitrary 100 for consistency.


\subsubsection{Random Number Generator%
  \label{random-number-generator}%
}

File: \texttt{random.h}

A LCG is used as the random number generator. It uses the GCC values as noted on Wikipedia. The seed is multiplied by an arbitrary number to get the generator going.


\subsubsection{Assert%
  \label{assert}%
}

The assert statement has been enhanced to show Thomas The Tank Engine. Please do not be alarmed when you see it.


\section{Source Code%
  \label{source-code}%
}

The source code is located at \texttt{/u4/chfoo/cs452/group/k2a-submit/io/kernel2}. It can be compiled by running \texttt{make}.

Source code MD5 hashes:
%
\begin{quote}{\ttfamily \raggedright \noindent
chfoo@nettop38:\textasciitilde{}/cs452/group/k2a-submit/io/kernel2\$~md5sum~*/*.*~*.*\\
~~~~50ef0e1e3c71ab1e795fc3d39f75ef9d~~include/bwio.h\\
~~~~9af226f127c1fd759530cd45236c37b8~~include/ts7200.h\\
~~~~da5c58f5a70790d853646f4a76f4c540~~buffer.c\\
~~~~1f9a730c5017ddd24e18523d27dc471e~~buffer.h\\
~~~~e270fd64ae08a0317d37fadedd24cabb~~kern.c\\
~~~~147be2be54ef2d9f4cad65a5794e7db7~~kern.elf\\
~~~~d41d8cd98f00b204e9800998ecf8427e~~kern.h\\
~~~~b00a171e052d7c818750f58a3bdcf27c~~kernel\_control\_flow.pdf\\
~~~~52dd3c8bac8b93e7bc9024ca3e56b00a~~kernel\_stack.pdf\\
~~~~84a5537b040cccb5d8ef47b4915018e8~~kernel\_state.h\\
~~~~7a7803ae8e9733a3bb9e27f07a2e0855~~memory.c\\
~~~~c782fb4d47461c3c448d646ff43271c3~~memory.h\\
~~~~adcff2244ac92050360eacd7ab4f5dd9~~message.c\\
~~~~04eded8ccd08bc5f73ff2eaf0274f076~~message.h\\
~~~~e80ae585145cca0cc59cc19c9dcf9b7b~~nameserver.c\\
~~~~53f58016672e3a2a02c3a5aee480ec50~~nameserver.h\\
~~~~4aa618b9753c5292e5d9e5c95d297f10~~orex.ld\\
~~~~e208b867b9bac6cf5c81c6d73f9b3f8d~~private\_kernel\_interface.c\\
~~~~bef673553ff2738e5355c9c0d8c9fb77~~private\_kernel\_interface.h\\
~~~~0656c0cea9a29f56d2db883a50ef0884~~public\_kernel\_interface.c\\
~~~~774ba0cc7254fa6203bc796b85d716cb~~public\_kernel\_interface.h\\
~~~~8bb4ea6e2e00ae9c9bad30f682dbe9af~~queue.c\\
~~~~8c282e71bf30800f9d749685dba46de5~~queue.h\\
~~~~91fbdbffeb090806d35dc54cb2e0627a~~random.c\\
~~~~7b31c57ff692317d816c839156382596~~random.h\\
~~~~5346b105cb8defb34e3aa6c4a853ff5c~~readme.pdf\\
~~~~e18b4677ae9866d43b7711a219042fff~~readme.rst\\
~~~~a03dcb23183838a3968c9e4cf1fa1183~~readme.tex\\
~~~~3bf0193cced01283304b36167df3594a~~robio.c\\
~~~~6fe98c156b7860cd10e5c8e7c7ef39ef~~robio.h\\
~~~~f207d682e54e737639f45f3a17078b6b~~rps.c\\
~~~~89e7636353a31fd35b73a82ee49a20e0~~rps.h\\
~~~~d55a63fb8522de9736cc3833ff0a9025~~swi\_kernel\_interface.s\\
~~~~d22a28c9457c285a63ea0ff7091b5f6b~~task\_descriptor.c\\
~~~~db54248f4493240552b83a78d7656822~~task\_descriptor.h\\
~~~~1d21eae6d91007bfd0d6dd6e35266aa9~~tasks.c\\
~~~~e1bc57af359db93c3982f8c0af896fcc~~tasks.h\\
~~~~952d806f62f1ef2d28b508485a7545c2~~timing.ods
}
\end{quote}

Elf MD5 hash:
%
\begin{quote}{\ttfamily \raggedright \noindent
chfoo@nettop38:/u/cs452/tftp/ARM/relder-chfoo/k2a-submit\$~md5sum~kern.elf\\
147be2be54ef2d9f4cad65a5794e7db7~~kern.elf
}
\end{quote}

Git sha1 hash: \texttt{7f890df902b0c688f32fb0488ffe15032964f1c1}


\section{Output%
  \label{output}%
}

The executable prints:
%
\begin{itemize}

\item Task creation

\item Who wants to play

\item Who wants to sign up

\item What clients choose

\item The pair the server has decided to play

\item The result of the game

\item The client's reasoning for winning/losing

\item When a client quits

\end{itemize}

In Summary:
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Server and Clients start up

\item Clients request to play

\item Games are played

\item One client quits and the system tries to shutdown

\item Clean exit
\end{list}

Note that a keyboard response is needed when the \emph{client} gets the result. This allows us to see what the \emph{server} decided before continuing execution. So two presses of the keyboard are needed for each round.


\section{Performance Measurement%
  \label{performance-measurement}%
}

\setlength{\DUtablewidth}{\linewidth}
\begin{longtable*}[c]{|p{0.179\DUtablewidth}|p{0.086\DUtablewidth}|p{0.214\DUtablewidth}|p{0.156\DUtablewidth}|p{0.075\DUtablewidth}|p{0.121\DUtablewidth}|}
\hline
\textbf{%
Message length
} & \textbf{%
Caches
} & \textbf{%
Send before Reply
} & \textbf{%
Optimization
} & \textbf{%
Group
} & \textbf{%
Time (us)
} \\
\hline
\endfirsthead
\hline
\textbf{%
Message length
} & \textbf{%
Caches
} & \textbf{%
Send before Reply
} & \textbf{%
Optimization
} & \textbf{%
Group
} & \textbf{%
Time (us)
} \\
\hline
\endhead
\multicolumn{6}{c}{\hfill ... continued on next page} \\
\endfoot
\endlastfoot

4
 & 
off
 & 
yes
 & 
off
 & 
2
 & 
549
 \\
\hline

64
 & 
off
 & 
yes
 & 
off
 & 
2
 & 
2088
 \\
\hline

4
 & 
on
 & 
yes
 & 
off
 & 
2
 & 
broken
 \\
\hline

64
 & 
on
 & 
yes
 & 
off
 & 
2
 & 
broken
 \\
\hline

4
 & 
off
 & 
no
 & 
off
 & 
2
 & 
547
 \\
\hline

64
 & 
off
 & 
no
 & 
off
 & 
2
 & 
2090
 \\
\hline

4
 & 
on
 & 
no
 & 
off
 & 
2
 & 
broken
 \\
\hline

64
 & 
on
 & 
no
 & 
off
 & 
2
 & 
broken
 \\
\hline

4
 & 
off
 & 
yes
 & 
on
 & 
2
 & 
broken
 \\
\hline

64
 & 
off
 & 
yes
 & 
on
 & 
2
 & 
broken
 \\
\hline

4
 & 
on
 & 
yes
 & 
on
 & 
2
 & 
broken
 \\
\hline

64
 & 
on
 & 
yes
 & 
on
 & 
2
 & 
broken
 \\
\hline

4
 & 
off
 & 
no
 & 
on
 & 
2
 & 
broken
 \\
\hline

64
 & 
off
 & 
no
 & 
on
 & 
2
 & 
broken
 \\
\hline

4
 & 
on
 & 
no
 & 
on
 & 
2
 & 
broken
 \\
\hline

64
 & 
on
 & 
no
 & 
on
 & 
2
 & 
broken
 \\
\hline
\end{longtable*}

\end{document}

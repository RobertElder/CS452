\documentclass[letterpaper,12pt]{article}
% generated by Docutils <http://docutils.sourceforge.net/>
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{0}
\usepackage{longtable,ltcaption,array}
\setlength{\extrarowheight}{2pt}
\newlength{\DUtablewidth} % internal use in tables
\usepackage{tabularx}

%%% Custom LaTeX preamble
% PDF Standard Fonts
\usepackage{mathptmx} % Times
\usepackage[scaled=.90]{helvet}
\usepackage{courier}

%%% User specified packages and stylesheets
\usepackage{fullpage}
\usepackage{microtype}
\usepackage[htt]{hyphenat}

%%% Fallback definitions for Docutils-specific commands

% providelength (provide a length variable and set default, if it is new)
\providecommand*{\DUprovidelength}[2]{
  \ifthenelse{\isundefined{#1}}{\newlength{#1}\setlength{#1}{#2}}{}
}

% docinfo (width of docinfo table)
\DUprovidelength{\DUdocinfowidth}{0.9\textwidth}

% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
  \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
  \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}
\hypersetup{
  pdftitle={CS 452 K1},
}

%%% Title Data
\title{\phantomsection%
  CS 452 K1%
  \label{cs-452-k1}}
\author{}
\date{}

%%% Body
\begin{document}
\maketitle

% Docinfo
\begin{center}
\begin{tabularx}{\DUdocinfowidth}{lX}
\textbf{Names}: &
Robert Elder, Christopher Foo
\\
\textbf{ID \#}: &
20335246, 20309244
\\
\textbf{Userids}: &
relder, chfoo
\\
\textbf{Date due}: &
May 27, 2013
\\
\end{tabularx}
\end{center}


\section{Running%
  \label{running}%
}

The executable is located at \texttt{/u/cs452/tftp/ARM/relder-chfoo/k1-submit/kern.elf}.

It is executed using the regular commands:
%
\begin{quote}{\ttfamily \raggedright \noindent
load~-b~0x00218000~-h~10.15.167.4~ARM/relder-chfoo/k1-submit/kern.elf\\
go
}
\end{quote}


\section{Description%
  \label{description}%
}


\subsection{Kernel%
  \label{kernel}%
}

The entry point is located in \texttt{kern.c}.

The kernel follows the following:
\newcounter{listcnt0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item Sets the location of our SWI routine.

\item Sets the stack pointer to accommodate our Kernel State.

\item Initialize the kernel (File \texttt{private\_kernel\_interface.c}:\texttt{k\_InitKernel()}).
\newcounter{listcnt1}
\begin{list}{\arabic{listcnt1}.}
{
\usecounter{listcnt1}
\setlength{\rightmargin}{\leftmargin}
}

\item Save the SP and LR values so the kernel can exit back to RedBoot.

\item Initialize the pseudo Task Descriptor.

\item Initialize the queues.

\item Set the SP and LR value of the pseudo Task Descriptor to the Kernel State

\item Call the \texttt{asm\_KernelExit} routine to push the values to the register.
\end{list}

\item Jump to KernelTask\_Start (File \texttt{tasks.c})

\item Start our first user task that starts the 4 other generic tasks.
\end{list}


\subsubsection{Scheduling%
  \label{scheduling}%
}

Scheduling occurs for all kernel calls. Before the current task descriptor is swapped out,
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item The user task's SP, LR, and SPSR values are saved into the current task descriptor.

\item Any related values are also saved into the TD.

\item The next task is selected (\texttt{schedule\_next\_task()}).
\setcounter{listcnt1}{0}
\begin{list}{\arabic{listcnt1}.}
{
\usecounter{listcnt1}
\setlength{\rightmargin}{\leftmargin}
}

\item The current task is set to \texttt{READY}.

\item A task is removed from the Priority Queue.
%
\begin{itemize}

\item Any tasks in the \texttt{ZOMBIE} state are not re-queued. Go back to step 1.

\end{itemize}

\item Use the pointer to the task as the next task to be run.

\item Set the selected task as \texttt{ACTIVE}.

\item Reschedule the selected task by adding it back to the Priority Queue.
\end{list}

\item If there no more tasks in the Priority Queue, the kernel exits back to RedBoot using the values we saved on the Kernel State.

\item Otherwise, the SP, LR, and return values are saved into the Kernel State.

\item Assembly routine \texttt{asm\_KernelExit} pushes these values to the registers.
\end{list}


\subsubsection{User tasks%
  \label{user-tasks}%
}

The tasks are defined in \texttt{tasks.c}.

\texttt{KernelTask} is a pseudo task with a pseudo task descriptor. It is simply used to start the first user task and does not get rescheduled. It has a task id of 0.

The first user task is called \texttt{FirstTask}. It has a task id of 1. The other tasks are called \texttt{GenericTask}.


\subsubsection{System Calls%
  \label{system-calls}%
}

The system calls should be complete in respect to the specifications.
%
\begin{description}
\item[{\texttt{Create}}] \leavevmode 
Returns the new task id, \texttt{ERR\_K\_INVALID\_PRIORITY -1}, or \texttt{ERR\_K\_OUT\_OF\_TD -2}

\item[{\texttt{MyTid}}] \leavevmode 
Returns the current task id

\item[{\texttt{MyParentTid}}] \leavevmode 
Returns the parent task id. The parent task id is always returned regardless of the parent's state.

\item[{\texttt{Pass}}] \leavevmode 
(Rescheduling happens as normal in the background.)

\item[{\texttt{Exit}}] \leavevmode 
Task is marked as \texttt{ZOMBIE} (and rescheduling happens as normal in the background).

\end{description}


\subsection{Algorithms and Data structures%
  \label{algorithms-and-data-structures}%
}


\subsubsection{Queue%
  \label{queue}%
}

File: \texttt{queue.c}

The queue, a \texttt{struct}, is implemented as a ring buffer. A start and end index is used to point to the start and end of the array. Each item is a \texttt{void*}. The ring buffer allows adding and removing an item from the queue in constant time. A null pointer is returned if the queue is empty.


\subsubsection{Priority Queue%
  \label{priority-queue}%
}

The priority queue consists of 5 queues for 5 levels of priority: highest, high, normal, low, and lowest. \texttt{NORMAL} is the default priority. Adding and removing an item is constant time.

\setlength{\DUtablewidth}{\linewidth}
\begin{longtable*}[c]{|p{0.110\DUtablewidth}|p{0.051\DUtablewidth}|}
\hline
\textbf{%
Priority
} & \textbf{%
Int
} \\
\hline
\endfirsthead
\hline
\textbf{%
Priority
} & \textbf{%
Int
} \\
\hline
\endhead
\multicolumn{2}{c}{\hfill ... continued on next page} \\
\endfoot
\endlastfoot

HIGHEST
 & 
1
 \\
\hline

HIGH
 & 
2
 \\
\hline

NORMAL
 & 
3
 \\
\hline

LOW
 & 
4
 \\
\hline

LOWEST
 & 
5
 \\
\hline
\end{longtable*}

Performance can be improved for removing an item in the priority queue. It currently checks all queues. An additional variable that tracks the highest, non-empty queue could be used.


\subsubsection{Task Descriptor (TD)%
  \label{task-descriptor-td}%
}

File: \texttt{task\_descriptor.c}

The TD, a \texttt{struct}, holds important information such as the task id, state, and return values.


\subsubsection{Kernel State%
  \label{kernel-state}%
}

File: \texttt{kernel\_state.h}

The Kernel State is a \texttt{struct} stored at \texttt{0x01500000 - sizeof(KernelState)}. It contains values such as the SP, LR, and return values that are set and retrieved in C code. Once these values are set, a routine is run in assembly code that pushes these values to the appropriate registers. The same information is also written to the struct directly when entering a kernel function.  This method makes it convenient for writing in C.

The Kernel State also contains information about the Task Descriptors.


\section{Source Code%
  \label{source-code}%
}

The source code is located at \texttt{/u4/chfoo/cs452/group/k1-submit/io/kernel-1-submission}. It can be compiled by running \texttt{make}.

Source code MD5 hashes:
%
\begin{quote}{\ttfamily \raggedright \noindent
chfoo@nettop37:\textasciitilde{}/cs452/group/k1-submit/io/kernel-1-submission\$~md5sum~*\\
6f52c9e07c8e16288b0f6e70ac1bbd52~~Makefile\\
bb97a5a42f82d99c9766caa1277ee231~~buffer.c\\
5be428c52822585e9e397ff12f9af96f~~buffer.h\\
e270fd64ae08a0317d37fadedd24cabb~~kern.c\\
634a19ff734f7bb6c8b33f110e66696b~~kern.elf\\
d41d8cd98f00b204e9800998ecf8427e~~kern.h\\
b00a171e052d7c818750f58a3bdcf27c~~kernel\_control\_flow.pdf\\
52dd3c8bac8b93e7bc9024ca3e56b00a~~kernel\_stack.pdf\\
98f7a503cb32985bcd45b4f75b1844d8~~kernel\_state.h\\
4aa618b9753c5292e5d9e5c95d297f10~~orex.ld\\
ee534990a4714e0699c3e38aae6ec9d1~~private\_kernel\_interface.c\\
bae820d4171cdc89818dbff01d5ac374~~private\_kernel\_interface.h\\
48aaad68699d272e84cc0794d9149d7a~~public\_kernel\_interface.c\\
90621ac9a036d7786da4b8afd2df482e~~public\_kernel\_interface.h\\
9cb336d84ff0e62c35f9c6ba24b5ab05~~queue.c\\
dd0449e95a89088411b71aac6825b6cf~~queue.h\\
50c0e650f22e669776f99c5b9fe41d84~~readme.rst\\
9070188c20a1d659520f46c95e8c60be~~robio.c\\
e9f9061a7e008eb95988b478164a75df~~robio.h\\
5b5afc928a7807d129e319ad4cd7c557~~swi\_kernel\_interface.s\\
89c7c55442b259b16bc5336bbc567fe2~~task\_descriptor.c\\
fa673eaf431d48587330386fa421a961~~task\_descriptor.h\\
a0b2c347ea4836aaf330c43bd55fdd9a~~tasks.c\\
e37b5f09bcd33f5c1665fe85fad38f6e~~tasks.h
}
\end{quote}

Elf MD5 hash:
%
\begin{quote}{\ttfamily \raggedright \noindent
chfoo@nettop37:/u/cs452/tftp/ARM/relder-chfoo/k1-submit\$~md5sum~kern.elf\\
634a19ff734f7bb6c8b33f110e66696b~~kern.elf
}
\end{quote}

Git sha1 hash: \texttt{cacb8815c528e5b1533254233b04c3ba4eb96c74}


\section{Output%
  \label{output}%
}

The executable prints the following:
\setcounter{listcnt0}{0}
\begin{list}{\arabic{listcnt0}.}
{
\usecounter{listcnt0}
\setlength{\rightmargin}{\leftmargin}
}

\item \texttt{FirstTask}, with ID 1, prints the message about creating two tasks 2 and 3

\item Task 4 executes.
%
\begin{itemize}

\item Task 4 executes because it is created with \texttt{HIGH} priority. The \texttt{FirstTask} has only \texttt{NORMAL} priority.

\end{itemize}

\item \texttt{FirstTask} prints that it created task 4.

\item Task 5 executes.
%
\begin{itemize}

\item Task 5 has \texttt{HIGH} priority

\end{itemize}

\item \texttt{FirstTask} prints that it created task 5.

\item \texttt{FirstTask} exits.

\item Task 2 runs.
%
\begin{itemize}

\item Task 2 has \texttt{LOW} priority so it runs only now.

\end{itemize}

\item Task 3 runs.

\item Task 2 runs.
%
\begin{itemize}

\item Task 2 and 3 have equal priority so they are queued right after each other.

\end{itemize}

\item Task 3 runs.
\end{list}

\end{document}
